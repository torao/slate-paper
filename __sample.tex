\documentclass[a4paper,11pt]{article}

\usepackage{geometry}
\geometry{margin=25mm}
\usepackage{titlesec}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{pxjahyper}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\setstretch{1.2}

\title{Slate: 分散ログ同期のための追記最適化マークルツリー}
% \title{Slate: An Append-Optimized Hash Tree for Distributed-Log Synchronization}
\author{鷹見 虎男}
\date{\today}
\hypersetup{
  pdftitle    = {Slate: 分散ログ同期のための追記最適化マークルツリー},
  pdfauthor   = {鷹見 虎男},
  pdfkeywords = {Stratified Hash Tree, Slate, 分散ログ, 追記最適化, 時間的局所性, 同期, 分岐検出, Merkle ツリー, ハッシュツリー}
}

\begin{document}
\maketitle

\begin{abstract}
大規模分散システムにおいて、分散するレプリカ間でのトランザクションログの迅速な修復と同期は、可用性・整合性・障害回復の性能に大きく影響する。現実的な分散ログは追記偏重のアクセス特性を持ち、その同期性能は分岐 (フォーク) の検出と修復の効率に大きく依存する。一方で、従来の方法はそのようなログ上で末尾からの線形探索で分岐を検出するため大規模なデータセットに対して非効率であり、適用可能な局面は限定的である。本論文は、大きな履歴遡及が頻繁に発生する状況でも効率的に機能する、追記最適化と時間局所性に基づくをアクセス特性を持つ Merkle Tree である \emph{Slate}（Stratified Hash Tree）を提案する。本論文ではまた、Slate において最新エントリから任意の位置のデータに到達するまでの I/O 回数分布がハミング距離に従うことを示し、分布の傾向により I/O が最新近傍で優先的に削減されることを理論化する。これに基づき、I/O がコスト支配的な一般的な状況において、$O(\log n)$ I/O での分岐位置の同定と $O(n)$ I/O での同期転送を満たす、暗号論的に確立された安全性に基づく修復手順を与える。さらに、証明サイズと比較ラウンド数について上界を導き、追記偏重のワークロードでの現実的な期待コストが最新データからのハミング距離に支配される非対称な性能特性を示す。

Rust の実装を用いた評価では、従来の Merkle Tree 構造に比べ、最新付近に偏る差分同期で転送量・探索 I/O・キャッシュミスが一貫して低減することを確認した。Slate は分散トランザクションログ、非同期レプリケーションログ、ブロックチェーン、および Git に類するハッシュグラフの分岐検出と修復に適用可能であり、追記最適化・時間局所性・認証性を両立する実用的基盤を提供する。
\end{abstract}

\textbf{Keywords}: Stratified Hash Tree, Slate, 分散ログ, 追記最適化, 時間的局所性, 分岐検出, 部分転送, 認証付きデータ構造

% \tableofcontents
% \newpage

Slate はデータ列を追記順に層として保存し、各エントリが過去の Merkle Tree への指数間隔の参照を持つことで、二次記憶装置に最適化された追記性能と、最近追加されたデータのアクセスがより少ない I/O 回数の傾向を持つ高速なアクセスを提供する。

\section{Introduction}

\subsection{1.1 Motivation (動機)}

追記専用ログ (append-only log) は現代の分散システムの基盤である。分散データベースやメッセージブローカーにおける先行書き込みログ (WAL)、ブロックチェーンシステムのトランザクションログ、分散バージョン管理システムのコミット履歴に至るまで、追記専用構造は永続性、複製、一貫性の基礎として機能している。これらのシステムが数十億のイベントとペタバイト級のデータを処理するようスケールするにつれ、ログ操作—特に検証、同期、分岐検出—の効率が決定的に重要となる。

Merkle \cite{merkle1989} によって先駆的に提案された暗号学的ハッシュツリーは、分散環境における信頼に不可欠な改ざん検知特性を提供する。Crosby と Wallach \cite{crosby2009} が導入した History Tree は、Merkle ツリーを拡張し、$O\log_2 n)$ サイズの証明による所属証明 (membership proof) と増分一貫性検証 (incremental consistency verification) の両方をサポートする追記専用ログを実現した。この設計は実世界で大きな成功を収めており、特に Certificate Transparency (CT) \cite{ct2021} では、グローバルに分散された数十億の証明書エントリを処理している。

しかし、既存のハッシュツリー設計はすべてのログエントリを均一に扱っている。$n$ エントリを持つ History Tree では、すべての葉ノードがルートからちょうど $\lfloor\log_2 n\rfloor$ ホップの位置にある。この\textbf{構造的均一性} (structural uniformity) は、現実世界の追記専用システムにおける根本的な特性である\textbf{時間的局所性} (temporal locality) のアクセスパターンと矛盾する。多様なドメインにまたがる実証分析により、最近のエントリがアクセスパターンを支配していることが明らかになっている：

\begin{itemize}
    \item \textbf{分散トランザクションログ}: 毎秒数百万のトランザクションを処理する高スループットなメッセージ指向ミドルウェアでは、クエリは圧倒的に最近のエントリを対象とする。監視、デバッグ、監査操作は、直近の数時間から数日間の活動に集中する。
    \item \textbf{Bitcoin の UTXO 消費}: Sornette ら \cite{sornette2025} は、Bitcoin の出力寿命がパレート分布に従うことを実証しており、大多数の UTXO は生成後すぐに消費される。この時間的偏りは偶然ではなく、暗号通貨利用の経済的現実を反映している。
    \item \textbf{分散バージョン管理}: 数百万のコミットを持つ git リポジトリでは、開発活動は最近の履歴に集中する。ブランチ間の分岐点を検出する git merge-base アルゴリズムは、ブランチの先頭から後方への線形探索を実行する。これは時間的局所性を活用する設計選択だが、$N$ と $M$ のコミットを持つブランチに対して最悪ケースで $O(N+M)$ に劣化する。
    \item \textbf{コンセンサスプロトコル}: Raft のログ複製メカニズム \cite{ongaro2014raft} は、リーダー交代時にフォロワーのログをログの末尾から比較することで同期する。新しいリーダーが選出されたとき、各フォロワーのログがどこで分岐しているかを特定しなければならない。現在のアプローチは後方への線形比較を実行するため、フォロワーが大幅に遅れている場合、ログ全体をスキャンするために $O(n)$ の操作が必要となる可能性がある。
\end{itemize}

このような普遍的な時間的偏りがあるにもかかわらず、標準的な Merkle ツリーや History Tree はこれを活用する構造的メカニズムを提供していない。History Tree では、エントリ $1$ にアクセスするにもエントリ $n$ にアクセスするにも、等しく $\lceil\log_2 n\rceil$ の操作が必要である。この均一性は理論的分析には洗練されているが、エントリ $n$ が数百万回アクセスされる一方でエントリ $1$ がほとんど触れられることのない現実世界のアクセスパターンとは根本的に不整合である。

現在の最先端アプローチ — Crosby と Wallach [14, Section 6.2] 自身が認めている — はキャッシング戦略に依存している。頻繁にアクセスされる最近のエントリを RAM に保持し、歴史的エントリはディスクに配置することを許容する。このエンジニアリング的解決策はパフォーマンス格差を緩和できるが、根本的な限界がある:

\begin{enumerate}
    \item \textbf{キャッシュの予測不可能性}: パフォーマンスが作業セットサイズに対する RAM 容量に依存するため、デプロイメント間で動作が不安定
    \item \textbf{構造的保証の欠如}: データ構造自体が最近のデータと歴史的データの間でパフォーマンス差別化を本質的に提供しない
    \item \textbf{同期の非効率性}: 2 つのログ間の分岐を検出するには依然としてエントリを 1 つずつ比較する必要があり、Raft や git のようなシステムで $O(n)$ の最悪ケース動作を引き起こす
\end{enumerate}

我々は、根本原因が既存ハッシュツリーの\textbf{構造的均一性}にあると観察する。すべてのエントリは、いつ追加されたか、どれだけ頻繁にアクセスされるかに関係なく、アーキテクチャ的にルートから等距離である。この均一性は、時間的位置を構造的組織化において無関係として扱う—追記専用ワークロードに内在する時間的局所性と矛盾する設計選択である。

本論文は \textbf{Slate} (Stratified Hash Tree、層様ハッシュツリー) を導入する。これは時間的局所性最適化をアーキテクチャ的に組み込んだ追記専用の認証データ構造である。すべてのログエントリを均一に扱うのではなく、Slate はツリー構造を層化し、最近のエントリを浅く構造的にアクセス可能な位置に配置する一方、歴史的エントリはより深い位置を占める。この層化により本質的なパフォーマンス勾配が生まれる：

\begin{itemize}
    \item \textbf{最近のデータ}: 最新エントリに対して $O(1)$ の I/O 操作、時間的距離が増加するにつれて徐々に劣化
    \item \textbf{歴史的データ}: 最悪ケース (最古エントリ) で $O(\log_2 n)$ の I/O 操作、これは History Tree の均一な境界と一致
    \item \textbf{分岐検出}: 2 つの追記専用ログが分岐する位置を特定するために最悪ケースで $O(\log_2 n)$ 操作、線形アプローチの $O(n)$ と比較して改善
\end{itemize}

鍵となる洞察は、\textbf{追記点からの時間的距離を構造的組織化原理として利用できる}ことである。これにより、パフォーマンス特性が現実世界のアクセスパターンと自然に整合する認証データ構造が生まれる。キャッシュ依存の最適化とは異なり、Slate の時間的局所性利益は構造的保証である。データ構造自体が、層化された階層における位置を通じて各エントリの新しさをエンコードしている。

Slate は暗号学的ハッシュツリーのすべての本質的特性—改ざん検知性、効率的な所属証明、増分一貫性検証—を維持しながら、最近のデータを優遇する非対称なアクセス効率を導入する。これにより、Slate は追記専用ログが最近のエントリへの頻繁なアクセスと歴史的一貫性の時折の検証の両方をサポートしなければならない分散システムに特に適している。

(残留物) \textbf{Merkle Tree} \cite{merkle1989} はデータ集合の完全性と任意のデータの包含 (所属) を証明することのできる、完全二分木構造を持つ暗号論的データ構造である。この木構造のルートのハッシュ値 (Merkle root) は葉ノードのすべてのデータを含む木構造全体の暗号学的コミットとメントと機能し、任意のデータの存在を $O(\log n)$ で検証できる。これはデータの完全性を効率的に保証するために分散システムにおいて広く利用されている。

(残留物) 基本的な Merkle Tree はデータ (葉ノード) 数が 2 のべき乗となる静的なデータ構造を対象としており、そのため動的な操作に対応するいくつかの亜種が提案されている。Crosby と Wallach \cite{crosby2009} が提案した \textbf{History Tree} は Merkle tree を追記可能 (append-only) な木構造へ拡張した。これは部分木が完全二分木となった時点で固定される (関数型プログラミング言語の文脈での) 部分的永続性データ構造 \cite{driscoll1986} を持つ。新しいデータの追加は $O(\log n)$ の時間で実行でき、包含証明 (inclusion proof) も $O(\log n)$ のサイズで生成できる。History Tree は二次記憶装置への write-once append-only で一度書き込まれたノードが不変であるような書き込みパターンと相性が良く、ディスクシークのオーバーヘッドを最小化できる。

\subsection{Brief History}
\subsection{Contributions}

\newpage

% \appendix
% \section{擬似コード}
% \section{証明補足}
% \section{評価スクリプトとデータセット概要}

\end{document}
